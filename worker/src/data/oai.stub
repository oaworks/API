
P.oai = () ->
  verb = @params.verb
  if verb
    verb = verb.toLowerCase()
    if verb is 'identify'
      res = @oai.pmh.identify 'https://' + @request.headers.host + '/oai'
    else if verb is 'listsets'
      res = @oai.pmh.sets 'https://' + @request.headers.host + '/oai'
    else if verb is 'listmetadataformats'
      res = @oai.pmh.formats 'https://' + @request.headers.host + '/oai'
    else if verb is 'listrecords'
      res = @oai.pmh.records 'https://' + @request.headers.host + '/oai'
    else if verb is 'listidentifiers'
      res = @oai.pmh.identifiers 'https://' + @request.headers.host + '/oai'
  res = @oai.pmh.bad 'verb', 'https://' + @request.headers.host + '/oai'
    
  return
    status: 200 # oai-pmh seems to just return errors as 200 but with the error info in the xml. The only difference is can return a 503 if temporarily unavailable, with a retry-after period specified
    headers: {'Content-Type': 'application/xml'}
    body: res


P.oai.pmh = {}

P.oai.pmh.identify = (endpoint, name, email) ->
  try endpoint ?= 'https://' + @request.headers.host + '/oai'
  earliestDatestamp = '2017-12-11T13:38:19Z' # get this from whatever index is being listed, earliest record in it
  granularity = 'YYYY-MM-DDThh:mm:ssZ' # what are the options? why is it so granular in doaj?
  deletedRecord = 'transient' # what is this?
  return '
<OAI-PMH xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.openarchives.org/OAI/2.0/" xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/ http://www.openarchives.org/OAI/2.0/OAI-PMH.xsd">
<responseDate>' + moment(Date.now(), "x").format("YYYY-MM-DDTHHmm:ssZ") + '</responseDate>
<request verb="Identify">' + identifier + '</request>
<Identify>
<repositoryName>' + name + '</repositoryName>
<baseURL>' + endpoint + '</baseURL>
<protocolVersion>2.0</protocolVersion>
<adminEmail>' + email + '</adminEmail>
<earliestDatestamp>' + earliestDatestamp + '</earliestDatestamp>
<deletedRecord>' + deletedRecord + '</deletedRecord>
<granularity>' + granularity + '</granularity>
</Identify>
</OAI-PMH>'

P.oai.pmh.sets = (endpoint, sets=[{spec: Random.id(), name: 'Example'}]) ->
  try endpoint ?= 'https://' + @request.headers.host + '/oai'
  ret = '
<OAI-PMH xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.openarchives.org/OAI/2.0/" xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/ http://www.openarchives.org/OAI/2.0/OAI-PMH.xsd">
<responseDate>' + moment(Date.now(), "x").format("YYYY-MM-DDTHHmm:ssZ") + '</responseDate>
<request verb="ListSets">' + endpoint + '</request>
<ListSets>'
  # what are set specs? doaj gen them as base64.urlsafe_b64encode(setspec).replace("=", "~")
  for set in sets # sets could be derived by a terms agg, ordered by term, with no counts, on a given key
    ret += '
<set>
<setSpec>' + set.spec + '</setSpec>
<setName>' + set.name + '</setName>
</set>'
  return ret + '
</ListSets>
</OAI-PMH>'

P.oai.pmh.formats = (endpoint, formats={'oai_dc': {schema: 'http://www.openarchives.org/OAI/2.0/oai_dc.xsd', namespace: 'http://www.openarchives.org/OAI/2.0/oai_dc/'}}) ->
  try endpoint ?= 'https://' + @request.headers.host + '/oai'
  ret =  '
<OAI-PMH xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.openarchives.org/OAI/2.0/" xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/ http://www.openarchives.org/OAI/2.0/OAI-PMH.xsd">
<responseDate>' + moment(Date.now(), "x").format("YYYY-MM-DDTHHmm:ssZ") + '</responseDate>
<request verb="ListMetadataFormats">' + endpoint + '</request>
<ListMetadataFormats>'
  for f of formats # could be configured in app settings, but more likely to be dependent on the service using this method (which may define them in its own app settings)
    ret += '
<metadataFormat>
<metadataPrefix>' + f + '</metadataPrefix>
<schema>' + formats[f].schema + '</schema>
<metadataNamespace>' + formats[f].namespace + '</metadataNamespace>
</metadataFormat>'
  return ret + '
</ListMetadataFormats>
</OAI-PMH>'

P.oai.pmh.header = (rec) ->
  # what is identifier, do we need to know endpoint? and should it include collection type or not?
  # what is datestamp? Is it last updated value?
  res = '<header xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:oai_dc="http://www.openarchives.org/OAI/2.0/oai_dc/">
<identifier>oai:doaj.org/journal:546e6a5c78344571b07f160f37c6e01d</identifier>
<datestamp>2018-07-23T11:20:30Z</datestamp>'
  for set in rec.sets
    # calculate the set spec from whatever is defined as sets - need to know which field in the record is being used as sets
    res += '<setSpec>TENDOkVkdWNhdGlvbg~~</setSpec>'
  return res + '</header>'

P.oai.pmh.metadata = (rec) ->
  # need to know which metadata type is being used, and the necessary attributes to describe that
  res = '<metadata xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:oai_dc="http://www.openarchives.org/OAI/2.0/oai_dc/">'
  res += '<oai_dc:dc xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/ http://www.openarchives.org/OAI/2.0/OAI-PMH.xsd">'
  shortcode = 'dc'
  for field in ['title', 'identifier', 'relation', 'publisher', 'date']
    # but there can be more than one identifier, relation
    # also some of these fields may not be in fields with exactly the same name - identifier is probably a list of objects
    # so need to define the model that goes from one record format to the specified metadataPrefix output record format
    # and prob needs to be specific to the application, as will have different record types (perhaps more than one per app too)
    res += '<' + shortcode + ':' + field + '>' + rec[field] + '</' + shortcode + ':' + field + '>' if rec[field]?
    # some examples:
    # <dc:title>Journal of Information Technology Education: Innovations in Practice</dc:title>
    # <dc:identifier>2165-3151</dc:identifier>
    # <dc:relation>http://www.informingscience.us/icarus/journals/jiteiip/submitpaper</dc:relation>
    # <dc:publisher>Informing Science Institute </dc:publisher>
    # <dc:date>2012-06-13T14:40:20Z</dc:date>
    # <dc:type>journal</dc:type>
    # <dc:subject>information technology</dc:subject>
    # <dc:subject xsi:type="dcterms:LCSH">Education</dc:subject>
  return res + '</oai_dc:dc></metadata>'

P.oai.pmh.record = (endpoint, collection, identifier) ->
  try endpoint ?= 'https://' + @request.headers.host + '/oai'
  # work out the ID from the identifier, and maybe the collection comes from there too
  rec = {}
  res = '' # what xml extra are needed for viewing just one record?
  res += await @oai.pmh.header rec
  res += await @oai.pmh.metadata rec # presumably record always contains metadata - does oai-pmh specify ability to request just a record header when not part of a list of records?
  # if cannot make this record into the request format, need to return CannotDisseminateFormat(base_url)
  return res

P.oai.pmh.records = (endpoint, collection, metadataPrefix='oai_dc', date_from, date_until, set, size=25, resumptionToken, metadata=true) ->
  try endpoint ?= 'https://' + @request.headers.host + '/oai'
  # query the collection - may require some default filtering too, like in_doaj: true
  # d = { "range" : { "last_updated" : {"gte" : "<from date>", "lte" : "<until date>"} } }
  # if there is a from_date, set a bool must range query d["range"]["last_updated"]["gte"] = from_date
  # if until_date set d["range"]["last_updated"]["lte"] = until_date
  # if there is an oai_set filter {"term" : { "index.schema_subject.exact" : "<set name>" }}
  # set size if size is given, changing from default of 25 on doaj
  # create a resumption token that is the query that generated this result set, but change the from_date to be 1ms after the last_updated date of the last record in the result set being provided now
  # would these sequential individual filtered queries be better than keeping a scroll snapshot of the index open for a long time?
  # if there about 3 million records (size of doaj) and theu are served in batches of 25, 
  # if each query takes 5s (at the moment it is slow so actually takes even longer), it 
  # will take nearly a year and a half to get all the data in this way, so that is no good. 
  # using paging of 10000 it would take about 25 hours. That could be reasonable, but don't want 
  # many scroll snapshots for many different oai queries hanging around for a day at a time
  # do scroll snapshots share their "state"? Probably not
  #run the query and return the total and the hits
  #result = list_records(dao, request.base_url, specified, **params)
  if resumptionToken? and (not metadataPrefix? or not date_from? or not date_until? or not set?)
    return @oai.pmh.bad 'argument', endpoint
  else if resumptionToken?
    try
      decoded = await @oai.pmh.resumptionToken.decode resumptionToken
      metadataPrefix = decoded.metadataPrefix if decoded.metadataPrefix?
      date_from = decoded.date_from
      date_until = decoded.date_until
      set = decoded.set
      size = decoded.size
    catch
      return @oai.pmh.bad 'resumptionToken', endpoint

  formats = {} #get formats from config somehwere, or input to the method
  # only proceed with metadataPrefix, suitable format, suitable set, and dates that meet format and granularity reqs
  return @oai.pmh.bad('argument', endpoint) if not metadataPrefix? # required by oai-pmh spec (although so far I set a default anyway)
  return @oai.pmh.bad('format', endpoint) if not formats?[metadataPrefix]?
  return @oai.pmh.bad('argument', endpoint) if ((date_from? and not API.oai.pmh.granularity(date_from)) or (date_until? and not API.oai.pmh.granularity(date_until)))
  try
    set = set #base64.urlsafe_b64decode(set.replace(/\~/g,"=")).decode("utf-8") if set? # change this from the python encode/decode to node
  catch
    return @oai.pmh.bad 'argument', endpoint

  q = {} #build q using provided values
  recs = collection.search q
  if recs?.total? and recs.total isnt 0
    res = '<OAI-PMH xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.openarchives.org/OAI/2.0/" xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/ http://www.openarchives.org/OAI/2.0/OAI-PMH.xsd">
<responseDate>' + moment(Date.now(), "x").format("YYYY-MM-DDTHHmm:ssZ") + '</responseDate>
<request verb="' + (if metadata then 'ListRecords' else 'ListIdentifiers') + '"'
    res += ' from="' + date_from + '"' if date_from? # note if using resumption tokens to adjust starting point, presumably this value still has to be the original query value - so track it through resumption tokens
    res += ' until="' + date_until + '"' if date_until?
    res += ' set="' + set + '"' if set?
    res += ' metadataPrefix="' + metadataPrefix + '"' if metadataPrefix?
    res += '>' + endpoint + '</request>'
    res += if metadata then '<ListRecords>' else '<ListIdentifiers>'
    for r in recs.hits.hits
      rec = r._source
      res += '<record>'
      res += await @oai.pmh.header rec
      res += await @oai.pmh.metadata(rec) if metadata
      res += '</record>'
    # example xml response below. Note that request attributes should be put in request element
    # put the results in the result object with correct format - each result needs header and metadata elements
    # can output more than one results metadata format at a time? or oai request only specifies just one?
    # add a resumption token if total is greater than results length - change the from date to the last_updated date of last record in current result set
    # if a resumption token was provided in this query but one is no longer needed, result should include the resumptionToken element but with no content
    # how long to honour resumption tokens? If setting a limit on them, need them to also contain their created timestamp - although that can be included as an option in the oai spec too
    # example <resumptionToken completeListSize="18" cursor="0" expirationDate="2018-07-24T13:14:21Z"/>
    res += if metadata then '</ListRecords>' else '</ListIdentifiers>'
    res += '</OAI-PMH>'
    return res
  else
    return @oai.pmh.bad 'query', endpoint # would be the oai norecordsmatch response
  
P.oai.pmh.identifiers = (endpoint, collection, metadataPrefix='oai_dc', date_from, date_until, set, size=25, resumptionToken) ->
  # same as records, but only includes the headers, not the metadata
  try endpoint ?= 'https://' + @request.headers.host + '/oai'
  return @oai.pmh.records endpoint, collection, metadataPrefix, date_from, date_until, set, size, resumptionToken, false

P.oai.pmh.resumptionToken = (metadataPrefix, date_from, date_until, set) ->
  t = {}
  t.m = metadataPrefix if metadataPrefix?
  t.df = date_from if date_from?
  t.du = date_until if date_until?
  t.s = set if set?
  t.c = Date.now() # this actually needs to be expirationDate, so add any timeout length to now, and format how it is displayed, if displaying in the xml
  return '' #base64.urlsafe_b64encode JSON.stringify(t) #change to node version of base 64 encode
  # could just return the actual xml element here, xml should have attribute of completeListSize and cursor if paging, and also expirationDate if there is one set
  
P.oai.pmh.resumptionToken.decode = (resumptionToken) ->
  try
    token = JSON.parse(base64.urlsafe_b64decode(resumptionToken)) # change to node base 64
    t = {}
    # check token.c against any token expiry length settings, don't process it if too old, return false
    t.metadataPrefix = token.m if token.m?
    t.date_from = token.df if token.df?
    t.date_until = token.du if token.du?
    t.set = token.s if token.s
    return t
  catch
    return {}

P.oai.pmh.granularity = () ->
  # need a list of allowed granularity date formats
  # for any incoming date, try to format it to one of the allowed formats
  # if successful, the format is good. If not, it isn't throw an error
  return true
  
P.oai.pmh.bad = (err, endpoint) ->
  try endpoint ?= 'https://' + @request.headers.host + '/oai'
  res = '
<OAI-PMH xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.openarchives.org/OAI/2.0/" xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/ http://www.openarchives.org/OAI/2.0/OAI-PMH.xsd">
<responseDate>' + moment(Date.now(), "x").format("YYYY-MM-DDTHHmm:ssZ") + '</responseDate>
<request>' + endpoint + '</request>'
  if err is 'verb'
    res += '<error code="badVerb">Value of the verb argument is not a legal OAI-PMH verb, the verb argument is missing, or the verb argument is repeated.</error>'
  else if err is 'resumptionToken'
    res += '<error code="badResumptionToken">The value of the resumptionToken argument is invalid or expired.</error>'
  else if err is 'format'
    res += '<error code="cannotDisseminateFormat">The metadata format identified by the value given for the metadataPrefix argument is not supported by the item or by the repository.</error>'
  else if err is 'query'
    res += '<error code="noRecordsMatch">The combination of the values of the from, until, set and metadataPrefix arguments results in an empty list.</error>'
  else if err is 'noformat'
    res += '<error code="noMetadataFormats">There are no metadata formats available for the specified item.</error>'
  else if err is 'noID'
    res += '<error code="idDoesNotExist">The value of the identifier argument is unknown or illegal in this repository.</error>'
  else if err is 'nohierarchy'
    res += '<error code="noSetHierarchy">The repository does not support sets.</error>'
  else
    res += '<error code="badArgument">The request includes illegal arguments, is missing required arguments, includes a repeated argument, or values for arguments have an illegal syntax.</error>'
  return res + '</OAI-PMH>'

